# Описание скрипта `clang-format_all_tree.sh`

## Назначение
Скрипт `clang-format_all_tree.sh` предназначен для автоматической проверки и форматирования исходных файлов на языке C (`*.c`, `*.h`) в текущей директории и всех её поддиректориях с помощью утилиты `clang-format`. Он также предоставляет возможность автоматического исправления форматирования при обнаружении несоответствий.

## Требования
- Установленная утилита `clang-format`.
- Файл стиля `.clang-format` (скрипт может скопировать его из указанного расположения, если файл отсутствует).

## Использование
1. Запустите скрипт в терминале:
   ```bash
   ./clang-format_all_tree.sh
   ```
## Функциональность
1. Проверка наличия clang-format
   Скрипт проверяет, установлена ли утилита clang-format. Если нет, выводится сообщение об ошибке.

2. Проверка наличия файла .clang-format
   Если файл .clang-format отсутствует в текущей директории, скрипт пытается скопировать его из указанного исходного расположения (../materials/linters/.clang-format).
   Если исходный файл также отсутствует, скрипт завершается с ошибкой.

3. Поиск файлов для проверки
   Скрипт рекурсивно ищет все файлы с расширениями .c и .h в текущей директории и её поддиректориях.

4. Проверка форматирования
   Для каждого найденного файла выполняется проверка соответствия стилю, указанному в .clang-format, с помощью команды:

```bash
  clang-format --style=file --dry-run --Werror "$file"
```
Если файл не соответствует стилю, его имя выводится на экран.

5. Автоматическое форматирование
   Если обнаружены файлы с несоответствующим форматированием, скрипт предлагает автоматически исправить их.
   Пользователь может выбрать:
   y/Y — исправить форматирование.
   n/N — пропустить исправление.
   Любой другой ввод — отмена форматирования.

Форматирование выполняется командой:

```bash
  clang-format --style=file -i "$file"
```

## Пример вывода
   ```
  Проверка форматирования файлов с помощью clang-format...
  Ошибка форматирования в файле: ./src/main.c
  Ошибка форматирования в файле: ./include/utils.h

  Найдены файлы, не соответствующие clang-format:
  ./src/main.c
  ./include/utils.h

  Хотите автоматически отформатировать эти файлы? (y/n): y
  Форматирование файлов...
  Отформатирован: ./src/main.c
  Отформатирован: ./include/utils.h
  Форматирование завершено.
  ```


# Описание скрипта tree_dir_and_file.sh
## Назначение
Скрипт tree_dir_and_file.sh предназначен для рекурсивного отображения структуры директорий и файлов в виде дерева. Результат сохраняется в указанный файл (по умолчанию tree.txt). Скрипт поддерживает ограничение глубины рекурсии для безопасной обработки глубоких структур каталогов.

## Использование
```bash
./tree_dir_and_file.sh <директория> [выходной_файл] [максимальная_глубина]
```
- <директория> — обязательный аргумент, путь к целевой директории
- [выходной_файл] — необязательный аргумент, имя файла для сохранения результата (по умолчанию tree.txt)
- [максимальная_глубина] — необязательный аргумент, ограничение глубины рекурсии (по умолчанию 20 уровней)

## Примеры использования:
```bash
./tree_dir_and_file.sh .                          # Глубина по умолчанию (20)
./tree_dir_and_file.sh . my_tree.txt              # Указание выходного файла
./tree_dir_and_file.sh . tree.txt 10              # Ограничение глубины 10 уровней
./tree_dir_and_file.sh /path/to/dir output.txt 5  # Полный формат
```

## Функциональность
1. Проверка аргументов
   - Скрипт проверяет, передан ли путь к директории. Если нет, выводится сообщение об ошибке и пример использования.
   - Если выходной файл не указан, используется имя tree.txt.
   - Если глубина рекурсии не указана, используется значение по умолчанию 20.

2. Проверка существования директории
   - Скрипт проверяет, существует ли указанная директория. Если нет, завершается с ошибкой.

3. Валидация параметров
   - Проверяет, что максимальная глубина является положительным числом.
   - Выводит понятное сообщение об ошибке при некорректном значении глубины.

4. Построение дерева каталогов с ограничением глубины
   - Используется рекурсивная функция build_tree, которая обходит все поддиректории.
   - Для визуализации структуры используются символы ├──, └── и отступы.
   - При достижении максимальной глубины выводится сообщение [глубина ограничена: X уровней].
   - Файлы и директории сортируются по именам.

5. Сохранение результата
   - Результат записывается в указанный файл.
   - В начало файла добавляется заголовок с указанием целевой директории, даты генерации и максимальной глубины.

## Пример вывода
Содержимое выходного файла (tree.txt):
```text
Дерево каталогов для: ./example
Генерируется: Wed Jul 17 12:34:56 UTC 2024
Максимальная глубина: 10 уровней

├── file1.txt
├── dir1
│   ├── subfile1.txt
│   └── subdir1
│       └── subsubdir1
│           └── [глубина ограничена: 10 уровней]
└── dir2
    └── file3.txt
```
## Особенности
   - Поддержка кириллических и сложных имен файлов/директорий
   - Корректная обработка скрытых файлов (начинающихся с точки)
   - Читаемое форматирование с отступами и символами псевдографики
   - Защита от бесконечной рекурсии через ограничение глубины
   - Обратная совместимость со старыми форматами вызова

# Описание скрипта tree_dir_and_file_bar.sh
## Назначение
Скрипт tree_dir_and_file_bar.sh является расширенной версией базового скрипта для построения дерева каталогов с добавлением интерактивного прогресс-бара. Он предоставляет визуальную обратную связь в процессе генерации дерева, что особенно полезно при работе с большими директориями.

## Использование
```bash
./tree_dir_and_file_bar.sh <директория> [выходной_файл] [максимальная_глубина]
```
   - <директория> — обязательный аргумент, путь к целевой директории
   - [выходной_файл] — необязательный аргумент, имя файла для сохранения результата (по умолчанию tree.txt)
   - [максимальная_глубина] — необязательный аргумент, ограничение глубины рекурсии (по умолчанию 20 уровней)

## Примеры использования:
```bash
./tree_dir_and_file_bar.sh .                          # Глубина по умолчанию (20)
./tree_dir_and_file_bar.sh . my_tree.txt              # Указание выходного файла
./tree_dir_and_file_bar.sh . tree.txt 10              # Ограничение глубины 10 уровней
./tree_dir_and_file_bar.sh /path/to/dir output.txt 5  # Полный формат
```
## Дополнительная функциональность (отличия от базовой версии)
1. Двухфазная обработка
   - Фаза подсчета: Предварительный подсчет всех элементов в директории для точного отображения прогресса
   - Фаза построения: Генерация дерева с визуальным отображением хода выполнения

2. Интерактивный прогресс-бар
   - Визуализация прогресса в реальном времени с помощью ASCII-графики
   - Отображение процента выполнения, текущего и общего количества элементов
   - Прогресс отображается только для элементов верхнего уровня для плавной анимации
   - Настраиваемая задержка анимации (0.1 секунды по умолчанию)

3. Расширенная информационная панель
   - Отдельный подсчет элементов верхнего уровня для прогресс-бара
   - Отображение общего количества элементов в директории
   - Информация о задержке анимации
   - Подробные статусные сообщения на каждом этапе

4. Улучшенная обработка ошибок
   - Детальные сообщения об ошибках доступа к директориям
   - Валидация всех входных параметров
   - Корректная обработка проблем с правами доступа

## Пример вывода в процессе выполнения
```text
Подсчет элементов в директории (максимальная глубина: 20)...
Найдено элементов: 1542

Подсчет элементов верхнего уровня...
Элементов верхнего уровня: 23
Задержка анимации: 0.1с

Генерация дерева каталогов (максимальная глубина: 20)...
Прогресс отображается по элементам верхнего уровня:
[=============                       ] 43% (10/23)
```
Особенности (дополнительные к базовой версии)
   - Визуальная обратная связь - пользователь видит прогресс выполнения для больших директорий
   - Плавная анимация - регулируемая задержка обеспечивает комфортное отображение прогресса
   - Детальная статистика - информация об элементах верхнего уровня и общем количестве
   - Оптимизированная производительность - прогресс-бар не замедляет основную работу скрипта
   - Профессиональный интерфейс - интуитивно понятное отображение хода выполнения

# Описание Makefile T12D18

## Этот Makefile предназначен для сборки и управления проектом, включающим несколько модулей и тестовых программ.

## Основные функции

### 1. Компиляция
- Поддержка модулей:
  - `print_module` (Quest_1)
  - `documentation_module` (Quest_2)
  - Тесты для работы с BST (Quest_3-5):
    - Создание узла (`bst_create_test`)
    - Вставка (`bst_insert_test`)
    - Обход (`bst_traverse_test`)
- Используются строгие флаги компиляции:
  ```makefile
  CFLAGS = -std=c11 -Wall -Werror -Wextra
  ```
  Поддержка санитайзеров:
  ```makefile
  SANITIZERS = -fsanitize=address -fsanitize=undefined -fsanitize=leak
  ```
  
### 2. Тестирование
Запуск тестов с санитайзерами:
```bash
make test        # Все тесты
make test_print  # Только print_module
```
Проверка памяти через Valgrind:
```bash
make valgrind
```
3. Управление артефактами
Автоматическое управление .gitignore:
```bash
make update_gitignore    # Добавить правила
make restore_gitignore  # Удалить правила
```
Очистка:
```bash
make clean            # Полная очистка
make clean_print      # Только print_module
```
4. Дополнительные инструменты
Проверка стиля кода:
```bash
make format-check  # Проверить
make format-fix    # Исправить
```
Статический анализ:
```bash
make cppcheck
```
5. Пересборка
```bash
make rebuild            # Полная пересборка
make rebuild_print      # Только print_module
```
Справка
```bash
make help
```
Выводит список всех доступных команд с описанием.

Примеры использования
```bash
make                    # Собрать всё
make test               # Собрать и запустить тесты
make clean && make all  # Полная пересборка
make print_module       # Собрать только print_module
```  
